antlr
    EBNF синтаксис
    LL(*) с улучшениями (умеет в некоторых случаях удалять левую рекурсию)
    IDE plugins (Itellij, netbeans, eclipse, visual studioetc.)
    BSD License
    Используется в Groovy, Jython, IntelliJ IDEA, Twitter
    Совместный лексер и парсер
    v4 Генерирует код в Java, C#, Python, Javascript (предыдущие версии поддерживали больше)
    фичи:
        Принимает любую грамматику кроме содержащих неявную левую рекурсию. Умеет удалять непосредственную левую рекурсию 
        Визуализатор дерева
        Может парсить некоторые context-sensistive языки, а также разрешать с помощью них неоднозначности в грамматике с помощью semantic predicates. Но я не уверен, что это всегда можно.
            http://meri-stuff.blogspot.com/2012/12/antlr-semantic-predicates.html
        ? * + ?? *? +?
        поддержка атрибутов : наследуемые и синтезируемые (не отменяет всякие хаки с динамическим scope)
        знает об ассоциативности операторов (по умолчанию влево)
        можно настраивать обработку ошибок
        лексер умеет поддерживать состояния (хотя это тривиально)
    TODO: 
        fuzzy parsing (channel?)?
    Проблемы:
        В документации периодически приходится угадывать о том, как вещи работают из примеров. Кроме того
            документация очень часто (примерно на каждой странице сайта antlr) ссылается на книгу,
            электронная копия которой стоит >=27$
    Резюме:
        <TODO>


bison
    Моё мнение не беспристрастно из-за того, что я пытаюсь использовать этот генератор парсеров для С++
    GPLv3
    LALR / GLR, экспериментально: IELR (никто об этом почти не слышал), LR(1)
    обратно совместим с грамматиками yacc
    yacc написан 1970, bison 1988
    BNF грамматика
    генерирует в C, C++, Java
    Используется в Ruby, PHP, Go, MySQL, Bash
    Лексер обычно отдаётся для lex/flex
    фичи:
        GLR парсер фактически позволяет работать с любой ctf грамматикой (хотя GLR, который реализован в bison потенциально может иметь экспонециальную сложность, хотя в теории мог бы иметь в худшем случае кубическую)
        Предикаты позволяют контролировать исполнение кода. Они более общие, чем ANTLR (который лишь ограниченно может их использовать для принятия решения, необх. но не достаточное условие, чтобы они были в начале ветвления. Иначе он просто кинет exception и попробует допарсить грамматику, как будто ничего не было)
    проблемы:
        синтаксис не самый приятный. Например использовать $$ и $i в качестве имён переменных это позапрошлый век. Пардон, в новых версиях он поддерживает именованные аргументы. Синтаксис не консистентный и порой бывают действительно "магические инструкции" пример?
        Если не использовать GLR парсер(?), shift-reduce и reduce-reduce конфликты трудно понимать (нужно разбираться в работе алгоритма)
        Приходится писать много вспомогательного кода прямо в грамматике, просто чтобы парсер начал что-то делать
            Например, нужно писать прологи, прологов может быть несколько, они могут перемешиваться с какими-то объявлениями
            и зависеть друг от друга. Выглядит всё это как постоянное жонглирование какими-то хаками.
        Приходится использовать препроцессор. 
        Ореинтирован на C, это сказывается.
        Грамматика всегда оказывается очень сильно связанной с кодом.
        Документация слишком длинная. Огромная её часть говорит о всяких архаизмах =(
        Чтобы сделать чистый парсер без сайдэффектов и засорения global namespace приходится возиться с кучей опций
            http://esr.ibiblio.org/?p=6341
        Скорей всего это чистый ад заставить работать несколько парсеров одновременно в одном проекте. Приходится возиться с опциями, которые дописывают префиксы ко всем функциям!! По умолчанию это yy. Следующий по популярности, это zz. Это пиздец.
        Как сделать локальные переменные для правила?
        Объявление типа синтезируемых атрибутов правил отделено собственно от места, где оно используется а-ля паскаль.
        С типом атрибутов полная каша. Во-первых существует около 5 несовместимых друг с другом способов объявления типов атрибутов. Далее bison не поддерживает нормальную типизацию, и тип на самом деле только один. Поэтому он просто собирает все типы в большое жирное объединение, а это означает потенциальные проблемы с проверкой типов. Причём даже фича, которая сама собирает типы в жирное объединение появилась недавно и не совместима с yacc. В новых версиях есть поддержка variant, что делает ситуацию немного лучше.
        Как сделать различные семантические возвращаемые значения для правила?
        Поддерживает наследуемые атрибуты, но совершенно безобразным образом: приходится индексироваться назад по стеку LR парсера. Это не безопасно, и нарушает идеи инкапсуляции со всеми вытекающими проблемами.
        По умолчанию генерирует LALR. Иногда это может создавать непонятные проблемы (см. "5.7 Mysterious Conflicts"), которые даже трудно идентифицирровать. Решение: использовать мало кому известный IELR (о нём похоже есть всего пара статьей и никакой информации в интернете) или LR(1) или GLR
        Нет стандартного способа визуализировать дерево разбора. Есть способ визуализировать парсер, но это обычно не практично
        Генерируемые файлы от flex огромны. Вместо того, чтобы подключать общую часть, они всё вываливают на месте. Из-за этого их сложней понимать.
        Грамматика сильно связана с конкретным кодом, который её использует. Использовать её в разных языках без модификации на грани невозомжного.
        Заставить работать flex по-нормальному с с++ довольно трудно. Как признаются сами разработчики в одном из комментариев:
                /* The c++ scanner is a mess. The FlexLexer.h header file relies on the
                 * following macro. This is required in order to pass the c++-multiple-scanners
                 * test in the regression suite. We get reports that it breaks inheritance.
                 * We will address this in a future release of flex, or omit the C++ scanner
                 * altogether.
                 */
        Нельзя вернуть семантическое значение после парсинга. Единственный способ: использовать какой-то state и хранить результат в нём.
        Обработка ошибок сложнее, чем в ANTLR и несколько работает. Более того, её сложнее настроить (у flex она не работает из коробки, и требует установки каких-то криптографических макросов)
        Семантический предикаты почему генерируют неправильный код с моими опциями.

    Резюме
        Если вы из любителей постоять в гамаке на одной ноге в акваланге, то этот генератор парсеров для вас.

Lemon
    Написан для sqlite
    LALR(1)
    BNF
    re-entrant и thread-safe по умолчанию, в отличии от bison
    Генерирует код толькко в C
    лицензия Public Domain
    Если писать под встроенные системы, то возможно, это очень хороший вариант
    Генерирует мало кода, причём то что генерирует, неплохо документировано
    Возможно, bison будет работать быстрей, однако
    Проще дизайн, чем у bison
    Крошечная документация
    Bison вызывает сам тащит токены (pull), здесь наоборот (push) (это приятней, можно, например писать парсер, работающий на бесконечных stream-ах)
    Из-за этого также легче тестировать
    Нет проблем использованием глобальных переменных
    Так как парсер никак не использует global state, для него очень просто написать обёртку для C++.
    Токенайзер в него легче встроить
    Проблемы:
        Генерирует код только в C
        Ограничен исключительно LALR(1). Нет дополнительных фич.
        Естественно, никаких вам variant-ов.
        И вообще почти никаких дополнительных фишек.
        Наследует почти все проблемы от bison
        Только синтезируемые атрибуты.
    Подводный камень:
        1. Генератор не генерирует объявления функций. Их нужно написать самому.
        2. Стандартный шаблон почему-то не подключает assert.h, хотя повсюду использует assert. (нужно подключить его самому)
        3. Скорей всего он не поставляется как пакет для дистрибутива. Поэтому его придётся несколько вручную подключать к проекто. Но по сути весь генератор парсеров, это всего один файл и его можно поставлять вместе с проектом.
    Резюме
        Если нужно писать на чистом C (особенно для встроенных систем), и важно reentrancy и нужно только что-то очень простое то может быть он и сойдёт. Плюс: его довольно легко изучить (из-за документации).Они довольно близко друг отдруга стоят. Если бы мне ничего специфичного не нужно было бы, и bison не был бы в моей оперативной памяти со всеми его особенностями, то я наверное предпочёл бы Lemon.

        Small size of generated code and memory footprint. It produces the smallest parser I found (I compared parsers of similar complexity generated by flex, bison, ANTLR, and Lemon);
        Excellent support of embedded systems: Lemon doesn't depend on standard library, you can specify external memory management functions, debug logging is removable.
        Public domain license. There is separate fork of Lemon licensed under GPLv2 that is not suitable for our needs because of viral license. So we get latest sqlite sources and compile Lemon out of them (it consists of only two files);
        Pull-parsing. It makes code more straightforward to understand and maintain than Flex/Bison parsing code. Thread-safety as an additional bonus I admire.
        Simple integration with tokenizers. Our project nature requires tokenizing of binary stream with variable tokens size. It was quite an easy to implemented tokenizer and integrate with parser API of only 3 functions and one feedback context variable. We investigated ways of integrating Lemon with re2c and Ragel and found them also quite easy to implement.
        Very simple syntax fast to learn.
        Lemon explicitly separate development of tokenizer and lexical analyzer(parser). My development flow starts with designing of parser grammar. I'm able to check complex rules with implicit token sequence by the means of several Parser(...) calls at this first stage. Tokenizer is implemented afterwards.

Boost::Spirit
    Что люди только не придумают, лишь бы не писать на хаскеле
    Boost license (близка к MIT license)
    LL, рекурсивный спуск
    PEG
    Язык, естественно только C++
    dsl строится на C++ шаблонах
    парсер (Qi), лексер(Lex), принтер(Karma)
    По сути комбинаторы парсеров на плюсовых темплейтах, аналогично Parsec
        отсюда плюсы и минусы:
            минусы: не поддерживается предпроцессинг, приходится вручную задавать
            ассоциативность операторов и порядок операторов через правила в грамматике, не поддерживается левая рекурсия.
            плюсы: dsl встроен в C++, легко смешивать семантику и грамматику (динамические парсеры), можно писать не только ctf грамматики, есть проверка типов, нормальные атрибуты (наверное), можно надеется на оптимизации со стороны компилятора. Теоретически должен генерировать довольно быстрые парсеры. Можно повышать уровень абстракции, делать свои комбинаторы из существующих.
    Так много шаблонов, то стандартные проблемы: увеличивается размер кода и время компиляции (и память требуемая для компиляции. Её может даже случайно не хватить.) (правда ли это на самом деле??)
    синтезируемые, наследуемые атрибуты
    Почти не используют для парсинга настоящих языков программирования, хотя есть контрпримеры. Часто используют для парсинга всяких DSL-ей
    Хорошая документация
    В семантических действиях используются индексы для указания нужного нетерминала. Плохо. (может есть способ именования переменных?)
    использует backtracking
    Внутреннюю машинерию может быть трудно понять.
    Язык dsl явно не минимальный. Нужно писать некоторое количество дополнительных объявлений. Это ограничения, накладываемые C++.
    Время комплияции огромно. Компляция небольшого примерчика xml парсера занимает 16 секунд и потребляет почти гигабайт оперативной памяти.
    Легко включить дебаг прямо в рантайме
    Резюме
        Концептуально вполне неплохой генератор парсеров, однако практически не подходит для работы над чем либо, что требует частого модифицирования парсера. Большое время компиляции скажется на трудности в отладке и вообще в использовании. Для каких-то небольших языков конфигов, наверное, впрочем, его ещё можно использовать. 

Elkhound
    GLR
    Используется в Elsa
    BSD License
    не разрабатывается уже 10 лет.
    И даже не компилируется.

pegged
    Boost License
    D язык, compile-time генрация кода
    recursive descend
    уже не развивается. Но если вы решили попробовать писать на D, то вы в любом любитель приключений и неизведанных территорий.
    Умеет грамматики, семантические действия
    Очень прост в использовании.
    Однако всегда генерирует полное AST (не нужно)
    Интересен просто как концепция.

    Резюме
        Если вы используете D, вы и так можете решить нужно вам это или нет.

pcre
    pcre != perl
    не буду сильно углубляться. есть много различных диалектов, и разные множества поддерживаемых фич.
    В том или ином виде поддерживается всеми
    Очень много диалектов и различий во всём.
    скорей всего PEG
    вот вам огромная таблица: https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines
    Не поддерживают ни семантических действий, ни атрибутов.
    Синтаксис не самый лакончиный, хотя, если скосить глаза, то читабельныый
    Поддерживают только текст. В зависимости от имплементации поддерживают только конкретный набор кодировок.
    Приходится вручную прописывать пробелы. Это легче, чем может показаться. Возможно есть способ хорошо это автоматизировать.
    флаг X позволит писать комментарии и форматировать выражение
    В зависимости от имплементации могут быть проблемы с восстановлением ast.
    Фактически в рантайме генерирует парсер.
    Как ни странно, писать грамматику не труднее классического варианта.
    Чтобы применить нужно только учить эпсилон синтаксиса, если знаком с обычными выражениями.
    С бэкреференсами - NP полны. Пример, классический 3-CNF SAT:
           (!$a ||  $b ||  $d)
        && ( $a || !$c ||  $d)
        && ( $a || !$b || !$d)
        && ( $b || !$c || !$d)
        && (!$a ||  $c || !$d)
        && ( $a ||  $b ||  $c)
        && (!$a || !$b || !$c)

        Трансформируем:
        $regex = '/^
            (x?)(x?)(x?)(x?) .* ;
            (?: x\1 | \2  | \4  ),
            (?: \1  | x\3 | \4  ),
            (?: \1  | x\2 | x\4 ),
            (?: \2  | x\3 | x\4 ),
            (?: x\1 | \3  | x\4 ),
            (?: \1  | \2  | \3  ),
            (?: x\1 | x\2 | x\3 ),
        $/x';

        и тестируем на : 'xxxx;x,x,x,x,x,x,x,'

        Если получим match, то значит она разрешима:
            array(5) {
              [0]=> string(19) "xxxx;x,x,x,x,x,x,x,"
              [1]=> string(1) "x"
              [2]=> string(1) "x"
              [3]=> string(0) ""
              [4]=> string(0) ""
            }
            тогда:  $a = true, $b = true, $c = false and $d = false
    Резюме:
        Если имплементация нормально поддерживает рекурсивный матчинг, то на ней
        можно писать простенькие парсеры. По сути PRCE это генератор парсеров в
        рантайме с немного неудобным синтаксисом. На их счёт есть много предрассудков.
        Большие парсеры может оказаться генерировать не удобно. Довольно искусственно ограниченны в использовании.

         Ещё интенсивное использование регекспом это весёлый способ обратить всех, кто читает твой код против себя.

parsec и прочие
    BSDv3
    Писать парсер несколько сложней, чем просто генерировать из грамматики
    Можно создавать свои комбинаторы парсеров, и управлять правилами на более абстрактном уровне
    Полностью поддерживает любые атрибуты, а также стейт
    рекурсивный спуск, PEG
    сильно языко-зависим
    Монады.
    Хорошая обработка ошибок.
    Туча вариаций.
    Грамматику за кодом программы может быть сложно увидеть

    megaparsec
    uu-parsinglib
    attoparsec
    polyparse

happy
    bnf
    используется, например в Agda и наверное много где ещё.
    язык haskell
    копирует релевантный синтаксис от yacc/bison 
    LALR, GLR
    использует по-прежнему нумерацию токенов
    Очень просто использовать
    Хорошая документация
    семантических предикатов нет (вроде бы).

что-то layout-sensitive
    indents
        bsd3
        основан на parsec
    indentparser
    indentation на hackage

bisonc++
    TODO

pyparsing - кажется монадические парсеры 